/**
 * Generated by API Builder - https://www.apibuilder.io
 * Service version: 0.2.8-1-g5b7388f-be1577bd-add-postman-collection
 * apibuilder 0.14.59 app.apibuilder.io/flow/chuck-onboarding/0.2.8-1-g5b7388f-be1577bd-add-postman-collection/play_2_x_json
 */
package io.flow.chuck.onboarding.v0.models {

  sealed trait Items extends _root_.scala.Product with _root_.scala.Serializable

  /**
   * Defines the valid type values for the type Items
   */
  sealed trait ItemsType extends _root_.scala.Product with _root_.scala.Serializable

  object ItemsType {

    case object Item extends ItemsType { override def toString = "item" }
    case object Folder extends ItemsType { override def toString = "folder" }

    final case class UNDEFINED(override val toString: String) extends ItemsType

    val all: scala.List[ItemsType] = scala.List(Item, Folder)

    private[this] val byName: Map[String, ItemsType] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): ItemsType = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[ItemsType] = byName.get(value.toLowerCase)

  }

  final case class Auth(
    `type`: io.flow.chuck.onboarding.v0.models.AuthEnum,
    basic: _root_.scala.Option[Seq[io.flow.chuck.onboarding.v0.models.BasicAuth]] = None
  )

  final case class BasicAuth(
    key: String,
    value: String,
    `type`: _root_.scala.Option[String] = None
  )

  final case class Body(
    raw: _root_.scala.Option[String] = None
  )

  /**
   * @param info Detailed description of the info block
   * @param item Items are the basic unit for a Postman collection. You can think of them as
   *        corresponding to a single API endpoint. Each Item has one request and may have
   *        multiple API responses associated with it.
   * @param event Postman allows you to configure scripts to run when specific events occur. These
   *        scripts are stored here, and can be referenced in the collection by their ID.
   * @param variable Collection variables allow you to define a set of variables, that are a part of
   *        the collection, as opposed to environments, which are separate entities.Note:
   *        Collection variables must not contain any sensitive information.
   * @param auth Represents authentication helpers provided by Postman
   */
  final case class Collection(
    info: io.flow.chuck.onboarding.v0.models.Info,
    item: Seq[io.flow.chuck.onboarding.v0.models.Items],
    event: Seq[io.flow.chuck.onboarding.v0.models.Event],
    variable: Seq[io.flow.chuck.onboarding.v0.models.Variable],
    auth: _root_.scala.Option[io.flow.chuck.onboarding.v0.models.Auth] = None
  )

  /**
   * @param content The content of the description goes here, as a raw string.
   * @param `type` Holds the mime type of the raw description content. E.g: 'text/markdown' or
   *        'text/html'. The type is used to correctly render the description when
   *        generating documentation, or in the Postman app.
   */
  final case class Description(
    content: _root_.scala.Option[String] = None,
    `type`: _root_.scala.Option[String] = None
  )

  /**
   * @param listen Can be set to test or prerequest for test scripts or pre-request scripts
   *        respectively.
   * @param id A unique identifier for the enclosing event.
   * @param disabled Indicates whether the event is disabled. If absent, the event is assumed to be
   *        enabled
   */
  final case class Event(
    listen: io.flow.chuck.onboarding.v0.models.EventType,
    script: _root_.scala.Option[io.flow.chuck.onboarding.v0.models.Script] = None,
    id: _root_.scala.Option[String] = None,
    disabled: _root_.scala.Option[Boolean] = None
  )

  /**
   * @param name A folder's friendly name is defined by this field. You would want to set this
   *        field to a value that would allow you to easily identify this folder.
   */
  final case class Folder(
    name: String,
    description: _root_.scala.Option[io.flow.chuck.onboarding.v0.models.Description] = None,
    variable: _root_.scala.Option[Seq[io.flow.chuck.onboarding.v0.models.Variable]] = None,
    item: Seq[io.flow.chuck.onboarding.v0.models.Item],
    event: _root_.scala.Option[Seq[io.flow.chuck.onboarding.v0.models.Event]] = None,
    auth: _root_.scala.Option[io.flow.chuck.onboarding.v0.models.Auth] = None
  ) extends Items

  final case class Header(
    key: String,
    value: String,
    disabled: _root_.scala.Option[Boolean] = None,
    description: _root_.scala.Option[io.flow.chuck.onboarding.v0.models.Description] = None
  )

  /**
   * @param name A collection's friendly name is defined by this field. You would want to set
   *        this field to a value that would allow you to easily identify this collection
   *        among a bunch of other collections, as such outlining its usage or content.
   * @param postmanId Every collection is identified by the unique value of this field. The value of
   *        this field is usually easiest to generate using a UID generator function. If you
   *        already have a collection, it is recommended that you maintain the same id since
   *        changing the id usually implies that is a different collection than it was
   *        originally.Note: This field exists for compatibility reasons with Collection
   *        Format V1.
   * @param description A Description can be a raw text, or be an object, which holds the description
   *        along with its format.
   * @param version Postman allows you to version your collections as they grow, and this field
   *        holds the version number. While optional, it is recommended that you use this
   *        field to its fullest extent!
   * @param schema This should ideally hold a link to the Postman schema that is used to validate
   *        this collection. E.g: https://schema.getpostman.com/collection/v1
   */
  final case class Info(
    name: String,
    postmanId: _root_.scala.Option[String] = None,
    description: _root_.scala.Option[io.flow.chuck.onboarding.v0.models.Description] = None,
    version: _root_.scala.Option[String] = None,
    schema: String
  )

  /**
   * @param id A unique ID that is used to identify collections internally
   * @param name A human readable identifier for the current item.
   * @param description A Description can be a raw text, or be an object, which holds the description
   *        along with its format.
   * @param variable Collection variables allow you to define a set of variables, that are a part of
   *        the collection, as opposed to environments, which are separate entities.
   * @param event Postman allows you to configure scripts to run when specific events occur. These
   *        scripts are stored here, and can be referenced in the collection by their ID.
   */
  final case class Item(
    id: _root_.scala.Option[String] = None,
    name: _root_.scala.Option[String] = None,
    description: _root_.scala.Option[io.flow.chuck.onboarding.v0.models.Description] = None,
    variable: _root_.scala.Option[Seq[io.flow.chuck.onboarding.v0.models.Variable]] = None,
    event: _root_.scala.Option[Seq[io.flow.chuck.onboarding.v0.models.Event]] = None,
    request: io.flow.chuck.onboarding.v0.models.Request,
    response: _root_.scala.Option[Seq[io.flow.chuck.onboarding.v0.models.Response]] = None
  ) extends Items

  final case class QueryParam(
    key: _root_.scala.Option[String] = None,
    value: _root_.scala.Option[String] = None,
    disabled: _root_.scala.Option[Boolean] = None,
    description: _root_.scala.Option[io.flow.chuck.onboarding.v0.models.Description] = None
  )

  final case class Request(
    url: _root_.scala.Option[io.flow.chuck.onboarding.v0.models.Url] = None,
    auth: _root_.scala.Option[io.flow.chuck.onboarding.v0.models.Auth] = None,
    method: _root_.scala.Option[io.flow.chuck.onboarding.v0.models.Method] = None,
    description: _root_.scala.Option[io.flow.chuck.onboarding.v0.models.Description] = None,
    header: _root_.scala.Option[Seq[io.flow.chuck.onboarding.v0.models.Header]] = None,
    body: _root_.scala.Option[io.flow.chuck.onboarding.v0.models.Body] = None
  )

  final case class Response(
    id: _root_.scala.Option[String] = None,
    name: _root_.scala.Option[String] = None,
    originalRequest: _root_.scala.Option[io.flow.chuck.onboarding.v0.models.Request] = None,
    responseTime: _root_.scala.Option[String] = None,
    header: _root_.scala.Option[Seq[io.flow.chuck.onboarding.v0.models.Header]] = None,
    body: _root_.scala.Option[String] = None,
    status: _root_.scala.Option[String] = None,
    code: _root_.scala.Option[Int] = None
  )

  /**
   * @param exec Body of the script in lines
   * @param `type` Type of the script. E.g: 'text/javascript'
   * @param id A unique, user defined identifier that can be used to refer to this script from
   *        requests.
   * @param src If object, contains the complete broken-down URL for this request. If string,
   *        contains the literal request URL.
   * @param name Script name
   */
  final case class Script(
    exec: Seq[String],
    `type`: String = "text/javascript",
    id: _root_.scala.Option[String] = None,
    src: _root_.scala.Option[String] = None,
    name: _root_.scala.Option[String] = None
  )

  /**
   * @param raw The string representation of the request URL, including the protocol, host,
   *        path, hash, query parameter(s) and path variable(s).
   * @param protocol The protocol_ associated with the request, E.g: 'http'
   * @param host The host for the URL, E.g: api.yourdomain.com. Can be stored as a string or as
   *        an array of strings.
   * @param port The port number present in this URL. An empty value implies 80/443 depending on
   *        whether the protocol_ field contains http/https.
   * @param hash Contains the URL fragment (if any). Usually this is not transmitted over the
   *        network, but it could be useful to store this in some cases.
   * @param variable Postman supports path variables with the syntax
   *        /path/:variableName/to/somewhere. These variables are stored in this field.
   */
  final case class Url(
    raw: _root_.scala.Option[String] = None,
    protocol: _root_.scala.Option[String] = None,
    host: _root_.scala.Option[Seq[String]] = None,
    path: _root_.scala.Option[Seq[String]] = None,
    port: _root_.scala.Option[String] = None,
    query: _root_.scala.Option[Seq[io.flow.chuck.onboarding.v0.models.QueryParam]] = None,
    hash: _root_.scala.Option[String] = None,
    variable: _root_.scala.Option[Seq[io.flow.chuck.onboarding.v0.models.Variable]] = None
  )

  /**
   * Using variables in your Postman requests eliminates the need to duplicate
   * requests, which can save a lot of time. Variables can be defined, and referenced
   * to from any part of a request.
   * 
   * @param id A variable ID is a unique user-defined value that identifies the variable within
   *        a collection. In traditional terms, this would be a variable name.
   * @param key A variable key is a human friendly value that identifies the variable within a
   *        collection. In traditional terms, this would be a variable name.
   * @param value The value that a variable holds in this collection. Ultimately, the variables
   *        will be replaced by this value, when say running a set of requests from a
   *        collection
   * @param `type` A variable may have multiple types. This field specifies the type of the
   *        variable.
   * @param name Variable name
   * @param system When set to true, indicates that this variable has been set by Postman
   */
  final case class Variable(
    id: _root_.scala.Option[String] = None,
    key: _root_.scala.Option[String] = None,
    value: _root_.scala.Option[String] = None,
    `type`: _root_.scala.Option[String] = None,
    name: _root_.scala.Option[String] = None,
    description: _root_.scala.Option[io.flow.chuck.onboarding.v0.models.Description] = None,
    system: _root_.scala.Option[Boolean] = None,
    disabled: _root_.scala.Option[Boolean] = None
  )

  /**
   * Provides future compatibility in clients - in the future, when a type is added
   * to the union Items, it will need to be handled in the client code. This
   * implementation will deserialize these future types as an instance of this class.
   * 
   * @param description Information about the type that we received that is undefined in this version of
   *        the client.
   */
  final case class ItemsUndefinedType(
    description: String
  ) extends Items

  sealed trait AuthEnum extends _root_.scala.Product with _root_.scala.Serializable

  object AuthEnum {

    case object Awsv4 extends AuthEnum { override def toString = "awsv4" }
    case object Basic extends AuthEnum { override def toString = "basic" }
    case object Bearer extends AuthEnum { override def toString = "bearer" }
    case object Digest extends AuthEnum { override def toString = "digest" }
    case object Hawk extends AuthEnum { override def toString = "hawk" }
    case object Noauth extends AuthEnum { override def toString = "noauth" }
    case object Oauth1 extends AuthEnum { override def toString = "oauth1" }
    case object Oauth2 extends AuthEnum { override def toString = "oauth2" }
    case object Ntlm extends AuthEnum { override def toString = "ntlm" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends AuthEnum

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[AuthEnum] = scala.List(Awsv4, Basic, Bearer, Digest, Hawk, Noauth, Oauth1, Oauth2, Ntlm)

    private[this]
    val byName: Map[String, AuthEnum] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): AuthEnum = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[AuthEnum] = byName.get(value.toLowerCase)

  }

  sealed trait EventType extends _root_.scala.Product with _root_.scala.Serializable

  object EventType {

    case object Test extends EventType { override def toString = "test" }
    case object Prerequest extends EventType { override def toString = "prerequest" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends EventType

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[EventType] = scala.List(Test, Prerequest)

    private[this]
    val byName: Map[String, EventType] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): EventType = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[EventType] = byName.get(value.toLowerCase)

  }

  sealed trait Method extends _root_.scala.Product with _root_.scala.Serializable

  object Method {

    case object Get extends Method { override def toString = "GET" }
    case object Put extends Method { override def toString = "PUT" }
    case object Post extends Method { override def toString = "POST" }
    case object Patch extends Method { override def toString = "PATCH" }
    case object Delete extends Method { override def toString = "DELETE" }
    case object Copy extends Method { override def toString = "COPY" }
    case object Head extends Method { override def toString = "HEAD" }
    case object Options extends Method { override def toString = "OPTIONS" }
    case object Link extends Method { override def toString = "LINK" }
    case object Unlink extends Method { override def toString = "UNLINK" }
    case object Purge extends Method { override def toString = "PURGE" }
    case object Lock extends Method { override def toString = "LOCK" }
    case object Unlock extends Method { override def toString = "UNLOCK" }
    case object Propfind extends Method { override def toString = "PROPFIND" }
    case object View extends Method { override def toString = "VIEW" }

    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends Method

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[Method] = scala.List(Get, Put, Post, Patch, Delete, Copy, Head, Options, Link, Unlink, Purge, Lock, Unlock, Propfind, View)

    private[this]
    val byName: Map[String, Method] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): Method = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[Method] = byName.get(value.toLowerCase)

  }

}

package io.flow.chuck.onboarding.v0.models {

  package object json {
    import play.api.libs.json.__
    import play.api.libs.json.JsString
    import play.api.libs.json.Writes
    import play.api.libs.functional.syntax._
    import io.flow.chuck.onboarding.v0.models.json._

    private[v0] implicit val jsonReadsUUID = __.read[String].map(java.util.UUID.fromString)

    private[v0] implicit val jsonWritesUUID = new Writes[java.util.UUID] {
      def writes(x: java.util.UUID) = JsString(x.toString)
    }

    private[v0] implicit val jsonReadsJodaDateTime = __.read[String].map { str =>
      import org.joda.time.format.ISODateTimeFormat.dateTimeParser
      dateTimeParser.parseDateTime(str)
    }

    private[v0] implicit val jsonWritesJodaDateTime = new Writes[org.joda.time.DateTime] {
      def writes(x: org.joda.time.DateTime) = {
        import org.joda.time.format.ISODateTimeFormat.dateTime
        val str = dateTime.print(x)
        JsString(str)
      }
    }

    private[v0] implicit val jsonReadsJodaLocalDate = __.read[String].map { str =>
      import org.joda.time.format.ISODateTimeFormat.dateParser
      dateParser.parseLocalDate(str)
    }

    private[v0] implicit val jsonWritesJodaLocalDate = new Writes[org.joda.time.LocalDate] {
      def writes(x: org.joda.time.LocalDate) = {
        import org.joda.time.format.ISODateTimeFormat.date
        val str = date.print(x)
        JsString(str)
      }
    }

    implicit val jsonReadsChuckOnboardingAuthEnum = new play.api.libs.json.Reads[io.flow.chuck.onboarding.v0.models.AuthEnum] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.chuck.onboarding.v0.models.AuthEnum] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.chuck.onboarding.v0.models.AuthEnum(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.chuck.onboarding.v0.models.AuthEnum(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesChuckOnboardingAuthEnum(obj: io.flow.chuck.onboarding.v0.models.AuthEnum) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectAuthEnum(obj: io.flow.chuck.onboarding.v0.models.AuthEnum) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesChuckOnboardingAuthEnum: play.api.libs.json.Writes[AuthEnum] = {
      new play.api.libs.json.Writes[io.flow.chuck.onboarding.v0.models.AuthEnum] {
        def writes(obj: io.flow.chuck.onboarding.v0.models.AuthEnum) = {
          jsonWritesChuckOnboardingAuthEnum(obj)
        }
      }
    }

    implicit val jsonReadsChuckOnboardingEventType = new play.api.libs.json.Reads[io.flow.chuck.onboarding.v0.models.EventType] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.chuck.onboarding.v0.models.EventType] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.chuck.onboarding.v0.models.EventType(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.chuck.onboarding.v0.models.EventType(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesChuckOnboardingEventType(obj: io.flow.chuck.onboarding.v0.models.EventType) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectEventType(obj: io.flow.chuck.onboarding.v0.models.EventType) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesChuckOnboardingEventType: play.api.libs.json.Writes[EventType] = {
      new play.api.libs.json.Writes[io.flow.chuck.onboarding.v0.models.EventType] {
        def writes(obj: io.flow.chuck.onboarding.v0.models.EventType) = {
          jsonWritesChuckOnboardingEventType(obj)
        }
      }
    }

    implicit val jsonReadsChuckOnboardingMethod = new play.api.libs.json.Reads[io.flow.chuck.onboarding.v0.models.Method] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[io.flow.chuck.onboarding.v0.models.Method] = {
        js match {
          case v: play.api.libs.json.JsString => play.api.libs.json.JsSuccess(io.flow.chuck.onboarding.v0.models.Method(v.value))
          case _ => {
            (js \ "value").validate[String] match {
              case play.api.libs.json.JsSuccess(v, _) => play.api.libs.json.JsSuccess(io.flow.chuck.onboarding.v0.models.Method(v))
              case err: play.api.libs.json.JsError => err
            }
          }
        }
      }
    }

    def jsonWritesChuckOnboardingMethod(obj: io.flow.chuck.onboarding.v0.models.Method) = {
      play.api.libs.json.JsString(obj.toString)
    }

    def jsObjectMethod(obj: io.flow.chuck.onboarding.v0.models.Method) = {
      play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(obj.toString))
    }

    implicit def jsonWritesChuckOnboardingMethod: play.api.libs.json.Writes[Method] = {
      new play.api.libs.json.Writes[io.flow.chuck.onboarding.v0.models.Method] {
        def writes(obj: io.flow.chuck.onboarding.v0.models.Method) = {
          jsonWritesChuckOnboardingMethod(obj)
        }
      }
    }

    implicit def jsonReadsChuckOnboardingAuth: play.api.libs.json.Reads[Auth] = {
      for {
        `type` <- (__ \ "type").read[io.flow.chuck.onboarding.v0.models.AuthEnum]
        basic <- (__ \ "basic").readNullable[Seq[io.flow.chuck.onboarding.v0.models.BasicAuth]]
      } yield Auth(`type`, basic)
    }

    def jsObjectAuth(obj: io.flow.chuck.onboarding.v0.models.Auth): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "type" -> play.api.libs.json.JsString(obj.`type`.toString)
      ) ++ (obj.basic match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("basic" -> play.api.libs.json.Json.toJson(x))
      })
    }

    implicit def jsonWritesChuckOnboardingAuth: play.api.libs.json.Writes[Auth] = {
      new play.api.libs.json.Writes[io.flow.chuck.onboarding.v0.models.Auth] {
        def writes(obj: io.flow.chuck.onboarding.v0.models.Auth) = {
          jsObjectAuth(obj)
        }
      }
    }

    implicit def jsonReadsChuckOnboardingBasicAuth: play.api.libs.json.Reads[BasicAuth] = {
      for {
        key <- (__ \ "key").read[String]
        value <- (__ \ "value").read[String]
        `type` <- (__ \ "type").readNullable[String]
      } yield BasicAuth(key, value, `type`)
    }

    def jsObjectBasicAuth(obj: io.flow.chuck.onboarding.v0.models.BasicAuth): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "key" -> play.api.libs.json.JsString(obj.key),
        "value" -> play.api.libs.json.JsString(obj.value)
      ) ++ (obj.`type` match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("type" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesChuckOnboardingBasicAuth: play.api.libs.json.Writes[BasicAuth] = {
      new play.api.libs.json.Writes[io.flow.chuck.onboarding.v0.models.BasicAuth] {
        def writes(obj: io.flow.chuck.onboarding.v0.models.BasicAuth) = {
          jsObjectBasicAuth(obj)
        }
      }
    }

    implicit def jsonReadsChuckOnboardingBody: play.api.libs.json.Reads[Body] = {
      (__ \ "raw").readNullable[String].map { x => new Body(raw = x) }
    }

    def jsObjectBody(obj: io.flow.chuck.onboarding.v0.models.Body): play.api.libs.json.JsObject = {
      (obj.raw match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("raw" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesChuckOnboardingBody: play.api.libs.json.Writes[Body] = {
      new play.api.libs.json.Writes[io.flow.chuck.onboarding.v0.models.Body] {
        def writes(obj: io.flow.chuck.onboarding.v0.models.Body) = {
          jsObjectBody(obj)
        }
      }
    }

    implicit def jsonReadsChuckOnboardingCollection: play.api.libs.json.Reads[Collection] = {
      for {
        info <- (__ \ "info").read[io.flow.chuck.onboarding.v0.models.Info]
        item <- (__ \ "item").read[Seq[io.flow.chuck.onboarding.v0.models.Items]]
        event <- (__ \ "event").read[Seq[io.flow.chuck.onboarding.v0.models.Event]]
        variable <- (__ \ "variable").read[Seq[io.flow.chuck.onboarding.v0.models.Variable]]
        auth <- (__ \ "auth").readNullable[io.flow.chuck.onboarding.v0.models.Auth]
      } yield Collection(info, item, event, variable, auth)
    }

    def jsObjectCollection(obj: io.flow.chuck.onboarding.v0.models.Collection): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "info" -> jsObjectInfo(obj.info),
        "item" -> play.api.libs.json.Json.toJson(obj.item),
        "event" -> play.api.libs.json.Json.toJson(obj.event),
        "variable" -> play.api.libs.json.Json.toJson(obj.variable)
      ) ++ (obj.auth match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("auth" -> jsObjectAuth(x))
      })
    }

    implicit def jsonWritesChuckOnboardingCollection: play.api.libs.json.Writes[Collection] = {
      new play.api.libs.json.Writes[io.flow.chuck.onboarding.v0.models.Collection] {
        def writes(obj: io.flow.chuck.onboarding.v0.models.Collection) = {
          jsObjectCollection(obj)
        }
      }
    }

    implicit def jsonReadsChuckOnboardingDescription: play.api.libs.json.Reads[Description] = {
      for {
        content <- (__ \ "content").readNullable[String]
        `type` <- (__ \ "type").readNullable[String]
      } yield Description(content, `type`)
    }

    def jsObjectDescription(obj: io.flow.chuck.onboarding.v0.models.Description): play.api.libs.json.JsObject = {
      (obj.content match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("content" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.`type` match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("type" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesChuckOnboardingDescription: play.api.libs.json.Writes[Description] = {
      new play.api.libs.json.Writes[io.flow.chuck.onboarding.v0.models.Description] {
        def writes(obj: io.flow.chuck.onboarding.v0.models.Description) = {
          jsObjectDescription(obj)
        }
      }
    }

    implicit def jsonReadsChuckOnboardingEvent: play.api.libs.json.Reads[Event] = {
      for {
        listen <- (__ \ "listen").read[io.flow.chuck.onboarding.v0.models.EventType]
        script <- (__ \ "script").readNullable[io.flow.chuck.onboarding.v0.models.Script]
        id <- (__ \ "id").readNullable[String]
        disabled <- (__ \ "disabled").readNullable[Boolean]
      } yield Event(listen, script, id, disabled)
    }

    def jsObjectEvent(obj: io.flow.chuck.onboarding.v0.models.Event): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "listen" -> play.api.libs.json.JsString(obj.listen.toString)
      ) ++ (obj.script match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("script" -> jsObjectScript(x))
      }) ++
      (obj.id match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("id" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.disabled match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("disabled" -> play.api.libs.json.JsBoolean(x))
      })
    }

    implicit def jsonWritesChuckOnboardingEvent: play.api.libs.json.Writes[Event] = {
      new play.api.libs.json.Writes[io.flow.chuck.onboarding.v0.models.Event] {
        def writes(obj: io.flow.chuck.onboarding.v0.models.Event) = {
          jsObjectEvent(obj)
        }
      }
    }

    implicit def jsonReadsChuckOnboardingFolder: play.api.libs.json.Reads[Folder] = {
      for {
        name <- (__ \ "name").read[String]
        description <- (__ \ "description").readNullable[io.flow.chuck.onboarding.v0.models.Description]
        variable <- (__ \ "variable").readNullable[Seq[io.flow.chuck.onboarding.v0.models.Variable]]
        item <- (__ \ "item").read[Seq[io.flow.chuck.onboarding.v0.models.Item]]
        event <- (__ \ "event").readNullable[Seq[io.flow.chuck.onboarding.v0.models.Event]]
        auth <- (__ \ "auth").readNullable[io.flow.chuck.onboarding.v0.models.Auth]
      } yield Folder(name, description, variable, item, event, auth)
    }

    def jsObjectFolder(obj: io.flow.chuck.onboarding.v0.models.Folder): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "name" -> play.api.libs.json.JsString(obj.name),
        "item" -> play.api.libs.json.Json.toJson(obj.item)
      ) ++ (obj.description match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("description" -> jsObjectDescription(x))
      }) ++
      (obj.variable match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("variable" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.event match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("event" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.auth match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("auth" -> jsObjectAuth(x))
      })
    }

    implicit def jsonReadsChuckOnboardingHeader: play.api.libs.json.Reads[Header] = {
      for {
        key <- (__ \ "key").read[String]
        value <- (__ \ "value").read[String]
        disabled <- (__ \ "disabled").readNullable[Boolean]
        description <- (__ \ "description").readNullable[io.flow.chuck.onboarding.v0.models.Description]
      } yield Header(key, value, disabled, description)
    }

    def jsObjectHeader(obj: io.flow.chuck.onboarding.v0.models.Header): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "key" -> play.api.libs.json.JsString(obj.key),
        "value" -> play.api.libs.json.JsString(obj.value)
      ) ++ (obj.disabled match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("disabled" -> play.api.libs.json.JsBoolean(x))
      }) ++
      (obj.description match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("description" -> jsObjectDescription(x))
      })
    }

    implicit def jsonWritesChuckOnboardingHeader: play.api.libs.json.Writes[Header] = {
      new play.api.libs.json.Writes[io.flow.chuck.onboarding.v0.models.Header] {
        def writes(obj: io.flow.chuck.onboarding.v0.models.Header) = {
          jsObjectHeader(obj)
        }
      }
    }

    implicit def jsonReadsChuckOnboardingInfo: play.api.libs.json.Reads[Info] = {
      for {
        name <- (__ \ "name").read[String]
        postmanId <- (__ \ "postman_id").readNullable[String]
        description <- (__ \ "description").readNullable[io.flow.chuck.onboarding.v0.models.Description]
        version <- (__ \ "version").readNullable[String]
        schema <- (__ \ "schema").read[String]
      } yield Info(name, postmanId, description, version, schema)
    }

    def jsObjectInfo(obj: io.flow.chuck.onboarding.v0.models.Info): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "name" -> play.api.libs.json.JsString(obj.name),
        "schema" -> play.api.libs.json.JsString(obj.schema)
      ) ++ (obj.postmanId match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("postman_id" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.description match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("description" -> jsObjectDescription(x))
      }) ++
      (obj.version match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("version" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesChuckOnboardingInfo: play.api.libs.json.Writes[Info] = {
      new play.api.libs.json.Writes[io.flow.chuck.onboarding.v0.models.Info] {
        def writes(obj: io.flow.chuck.onboarding.v0.models.Info) = {
          jsObjectInfo(obj)
        }
      }
    }

    implicit def jsonReadsChuckOnboardingItem: play.api.libs.json.Reads[Item] = {
      for {
        id <- (__ \ "id").readNullable[String]
        name <- (__ \ "name").readNullable[String]
        description <- (__ \ "description").readNullable[io.flow.chuck.onboarding.v0.models.Description]
        variable <- (__ \ "variable").readNullable[Seq[io.flow.chuck.onboarding.v0.models.Variable]]
        event <- (__ \ "event").readNullable[Seq[io.flow.chuck.onboarding.v0.models.Event]]
        request <- (__ \ "request").read[io.flow.chuck.onboarding.v0.models.Request]
        response <- (__ \ "response").readNullable[Seq[io.flow.chuck.onboarding.v0.models.Response]]
      } yield Item(id, name, description, variable, event, request, response)
    }

    def jsObjectItem(obj: io.flow.chuck.onboarding.v0.models.Item): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "request" -> jsObjectRequest(obj.request)
      ) ++ (obj.id match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("id" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.name match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("name" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.description match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("description" -> jsObjectDescription(x))
      }) ++
      (obj.variable match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("variable" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.event match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("event" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.response match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("response" -> play.api.libs.json.Json.toJson(x))
      })
    }

    implicit def jsonReadsChuckOnboardingQueryParam: play.api.libs.json.Reads[QueryParam] = {
      for {
        key <- (__ \ "key").readNullable[String]
        value <- (__ \ "value").readNullable[String]
        disabled <- (__ \ "disabled").readNullable[Boolean]
        description <- (__ \ "description").readNullable[io.flow.chuck.onboarding.v0.models.Description]
      } yield QueryParam(key, value, disabled, description)
    }

    def jsObjectQueryParam(obj: io.flow.chuck.onboarding.v0.models.QueryParam): play.api.libs.json.JsObject = {
      (obj.key match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("key" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.value match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.disabled match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("disabled" -> play.api.libs.json.JsBoolean(x))
      }) ++
      (obj.description match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("description" -> jsObjectDescription(x))
      })
    }

    implicit def jsonWritesChuckOnboardingQueryParam: play.api.libs.json.Writes[QueryParam] = {
      new play.api.libs.json.Writes[io.flow.chuck.onboarding.v0.models.QueryParam] {
        def writes(obj: io.flow.chuck.onboarding.v0.models.QueryParam) = {
          jsObjectQueryParam(obj)
        }
      }
    }

    implicit def jsonReadsChuckOnboardingRequest: play.api.libs.json.Reads[Request] = {
      for {
        url <- (__ \ "url").readNullable[io.flow.chuck.onboarding.v0.models.Url]
        auth <- (__ \ "auth").readNullable[io.flow.chuck.onboarding.v0.models.Auth]
        method <- (__ \ "method").readNullable[io.flow.chuck.onboarding.v0.models.Method]
        description <- (__ \ "description").readNullable[io.flow.chuck.onboarding.v0.models.Description]
        header <- (__ \ "header").readNullable[Seq[io.flow.chuck.onboarding.v0.models.Header]]
        body <- (__ \ "body").readNullable[io.flow.chuck.onboarding.v0.models.Body]
      } yield Request(url, auth, method, description, header, body)
    }

    def jsObjectRequest(obj: io.flow.chuck.onboarding.v0.models.Request): play.api.libs.json.JsObject = {
      (obj.url match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("url" -> jsObjectUrl(x))
      }) ++
      (obj.auth match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("auth" -> jsObjectAuth(x))
      }) ++
      (obj.method match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("method" -> play.api.libs.json.JsString(x.toString))
      }) ++
      (obj.description match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("description" -> jsObjectDescription(x))
      }) ++
      (obj.header match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("header" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.body match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("body" -> jsObjectBody(x))
      })
    }

    implicit def jsonWritesChuckOnboardingRequest: play.api.libs.json.Writes[Request] = {
      new play.api.libs.json.Writes[io.flow.chuck.onboarding.v0.models.Request] {
        def writes(obj: io.flow.chuck.onboarding.v0.models.Request) = {
          jsObjectRequest(obj)
        }
      }
    }

    implicit def jsonReadsChuckOnboardingResponse: play.api.libs.json.Reads[Response] = {
      for {
        id <- (__ \ "id").readNullable[String]
        name <- (__ \ "name").readNullable[String]
        originalRequest <- (__ \ "originalRequest").readNullable[io.flow.chuck.onboarding.v0.models.Request]
        responseTime <- (__ \ "responseTime").readNullable[String]
        header <- (__ \ "header").readNullable[Seq[io.flow.chuck.onboarding.v0.models.Header]]
        body <- (__ \ "body").readNullable[String]
        status <- (__ \ "status").readNullable[String]
        code <- (__ \ "code").readNullable[Int]
      } yield Response(id, name, originalRequest, responseTime, header, body, status, code)
    }

    def jsObjectResponse(obj: io.flow.chuck.onboarding.v0.models.Response): play.api.libs.json.JsObject = {
      (obj.id match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("id" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.name match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("name" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.originalRequest match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("originalRequest" -> jsObjectRequest(x))
      }) ++
      (obj.responseTime match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("responseTime" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.header match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("header" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.body match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("body" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.status match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("status" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.code match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("code" -> play.api.libs.json.JsNumber(x))
      })
    }

    implicit def jsonWritesChuckOnboardingResponse: play.api.libs.json.Writes[Response] = {
      new play.api.libs.json.Writes[io.flow.chuck.onboarding.v0.models.Response] {
        def writes(obj: io.flow.chuck.onboarding.v0.models.Response) = {
          jsObjectResponse(obj)
        }
      }
    }

    implicit def jsonReadsChuckOnboardingScript: play.api.libs.json.Reads[Script] = {
      for {
        exec <- (__ \ "exec").read[Seq[String]]
        `type` <- (__ \ "type").readWithDefault[String]("text/javascript")
        id <- (__ \ "id").readNullable[String]
        src <- (__ \ "src").readNullable[String]
        name <- (__ \ "name").readNullable[String]
      } yield Script(exec, `type`, id, src, name)
    }

    def jsObjectScript(obj: io.flow.chuck.onboarding.v0.models.Script): play.api.libs.json.JsObject = {
      play.api.libs.json.Json.obj(
        "exec" -> play.api.libs.json.Json.toJson(obj.exec),
        "type" -> play.api.libs.json.JsString(obj.`type`)
      ) ++ (obj.id match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("id" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.src match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("src" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.name match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("name" -> play.api.libs.json.JsString(x))
      })
    }

    implicit def jsonWritesChuckOnboardingScript: play.api.libs.json.Writes[Script] = {
      new play.api.libs.json.Writes[io.flow.chuck.onboarding.v0.models.Script] {
        def writes(obj: io.flow.chuck.onboarding.v0.models.Script) = {
          jsObjectScript(obj)
        }
      }
    }

    implicit def jsonReadsChuckOnboardingUrl: play.api.libs.json.Reads[Url] = {
      for {
        raw <- (__ \ "raw").readNullable[String]
        protocol <- (__ \ "protocol").readNullable[String]
        host <- (__ \ "host").readNullable[Seq[String]]
        path <- (__ \ "path").readNullable[Seq[String]]
        port <- (__ \ "port").readNullable[String]
        query <- (__ \ "query").readNullable[Seq[io.flow.chuck.onboarding.v0.models.QueryParam]]
        hash <- (__ \ "hash").readNullable[String]
        variable <- (__ \ "variable").readNullable[Seq[io.flow.chuck.onboarding.v0.models.Variable]]
      } yield Url(raw, protocol, host, path, port, query, hash, variable)
    }

    def jsObjectUrl(obj: io.flow.chuck.onboarding.v0.models.Url): play.api.libs.json.JsObject = {
      (obj.raw match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("raw" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.protocol match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("protocol" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.host match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("host" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.path match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("path" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.port match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("port" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.query match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("query" -> play.api.libs.json.Json.toJson(x))
      }) ++
      (obj.hash match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("hash" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.variable match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("variable" -> play.api.libs.json.Json.toJson(x))
      })
    }

    implicit def jsonWritesChuckOnboardingUrl: play.api.libs.json.Writes[Url] = {
      new play.api.libs.json.Writes[io.flow.chuck.onboarding.v0.models.Url] {
        def writes(obj: io.flow.chuck.onboarding.v0.models.Url) = {
          jsObjectUrl(obj)
        }
      }
    }

    implicit def jsonReadsChuckOnboardingVariable: play.api.libs.json.Reads[Variable] = {
      for {
        id <- (__ \ "id").readNullable[String]
        key <- (__ \ "key").readNullable[String]
        value <- (__ \ "value").readNullable[String]
        `type` <- (__ \ "type").readNullable[String]
        name <- (__ \ "name").readNullable[String]
        description <- (__ \ "description").readNullable[io.flow.chuck.onboarding.v0.models.Description]
        system <- (__ \ "system").readNullable[Boolean]
        disabled <- (__ \ "disabled").readNullable[Boolean]
      } yield Variable(id, key, value, `type`, name, description, system, disabled)
    }

    def jsObjectVariable(obj: io.flow.chuck.onboarding.v0.models.Variable): play.api.libs.json.JsObject = {
      (obj.id match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("id" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.key match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("key" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.value match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("value" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.`type` match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("type" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.name match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("name" -> play.api.libs.json.JsString(x))
      }) ++
      (obj.description match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("description" -> jsObjectDescription(x))
      }) ++
      (obj.system match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("system" -> play.api.libs.json.JsBoolean(x))
      }) ++
      (obj.disabled match {
        case None => play.api.libs.json.Json.obj()
        case Some(x) => play.api.libs.json.Json.obj("disabled" -> play.api.libs.json.JsBoolean(x))
      })
    }

    implicit def jsonWritesChuckOnboardingVariable: play.api.libs.json.Writes[Variable] = {
      new play.api.libs.json.Writes[io.flow.chuck.onboarding.v0.models.Variable] {
        def writes(obj: io.flow.chuck.onboarding.v0.models.Variable) = {
          jsObjectVariable(obj)
        }
      }
    }

    implicit def jsonReadsChuckOnboardingItems: play.api.libs.json.Reads[Items] = new play.api.libs.json.Reads[Items] {
      def reads(js: play.api.libs.json.JsValue): play.api.libs.json.JsResult[Items] = {
        (js \ "type").asOpt[String].getOrElse { sys.error("Union[Items] requires a discriminator named 'type' - this field was not found in the Json Value") } match {
          case "item" => js.validate[io.flow.chuck.onboarding.v0.models.Item]
          case "folder" => js.validate[io.flow.chuck.onboarding.v0.models.Folder]
          case other => play.api.libs.json.JsSuccess(io.flow.chuck.onboarding.v0.models.ItemsUndefinedType(other))
        }
      }
    }

    def jsObjectItems(obj: io.flow.chuck.onboarding.v0.models.Items): play.api.libs.json.JsObject = {
      obj match {
        case x: io.flow.chuck.onboarding.v0.models.Item => jsObjectItem(x) ++ play.api.libs.json.Json.obj("type" -> "item")
        case x: io.flow.chuck.onboarding.v0.models.Folder => jsObjectFolder(x) ++ play.api.libs.json.Json.obj("type" -> "folder")
        case other => {
          sys.error(s"The type[${other.getClass.getName}] has no JSON writer")
        }
      }
    }

    implicit def jsonWritesChuckOnboardingItems: play.api.libs.json.Writes[Items] = {
      new play.api.libs.json.Writes[io.flow.chuck.onboarding.v0.models.Items] {
        def writes(obj: io.flow.chuck.onboarding.v0.models.Items) = {
          jsObjectItems(obj)
        }
      }
    }
  }
}

package io.flow.chuck.onboarding.v0 {

  object Bindables {

    import play.api.mvc.{PathBindable, QueryStringBindable}

    // import models directly for backwards compatibility with prior versions of the generator
    import Core._
    import Models._

    object Core {
      implicit def pathBindableDateTimeIso8601(implicit stringBinder: QueryStringBindable[String]): PathBindable[_root_.org.joda.time.DateTime] = ApibuilderPathBindable(ApibuilderTypes.dateTimeIso8601)
      implicit def queryStringBindableDateTimeIso8601(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[_root_.org.joda.time.DateTime] = ApibuilderQueryStringBindable(ApibuilderTypes.dateTimeIso8601)

      implicit def pathBindableDateIso8601(implicit stringBinder: QueryStringBindable[String]): PathBindable[_root_.org.joda.time.LocalDate] = ApibuilderPathBindable(ApibuilderTypes.dateIso8601)
      implicit def queryStringBindableDateIso8601(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[_root_.org.joda.time.LocalDate] = ApibuilderQueryStringBindable(ApibuilderTypes.dateIso8601)
    }

    object Models {
      import io.flow.chuck.onboarding.v0.models._

      val authEnumConverter: ApibuilderTypeConverter[io.flow.chuck.onboarding.v0.models.AuthEnum] = new ApibuilderTypeConverter[io.flow.chuck.onboarding.v0.models.AuthEnum] {
        override def convert(value: String): io.flow.chuck.onboarding.v0.models.AuthEnum = io.flow.chuck.onboarding.v0.models.AuthEnum(value)
        override def convert(value: io.flow.chuck.onboarding.v0.models.AuthEnum): String = value.toString
        override def example: io.flow.chuck.onboarding.v0.models.AuthEnum = io.flow.chuck.onboarding.v0.models.AuthEnum.Awsv4
        override def validValues: Seq[io.flow.chuck.onboarding.v0.models.AuthEnum] = io.flow.chuck.onboarding.v0.models.AuthEnum.all
      }
      implicit def pathBindableAuthEnum(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.chuck.onboarding.v0.models.AuthEnum] = ApibuilderPathBindable(authEnumConverter)
      implicit def queryStringBindableAuthEnum(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.chuck.onboarding.v0.models.AuthEnum] = ApibuilderQueryStringBindable(authEnumConverter)

      val eventTypeConverter: ApibuilderTypeConverter[io.flow.chuck.onboarding.v0.models.EventType] = new ApibuilderTypeConverter[io.flow.chuck.onboarding.v0.models.EventType] {
        override def convert(value: String): io.flow.chuck.onboarding.v0.models.EventType = io.flow.chuck.onboarding.v0.models.EventType(value)
        override def convert(value: io.flow.chuck.onboarding.v0.models.EventType): String = value.toString
        override def example: io.flow.chuck.onboarding.v0.models.EventType = io.flow.chuck.onboarding.v0.models.EventType.Test
        override def validValues: Seq[io.flow.chuck.onboarding.v0.models.EventType] = io.flow.chuck.onboarding.v0.models.EventType.all
      }
      implicit def pathBindableEventType(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.chuck.onboarding.v0.models.EventType] = ApibuilderPathBindable(eventTypeConverter)
      implicit def queryStringBindableEventType(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.chuck.onboarding.v0.models.EventType] = ApibuilderQueryStringBindable(eventTypeConverter)

      val methodConverter: ApibuilderTypeConverter[io.flow.chuck.onboarding.v0.models.Method] = new ApibuilderTypeConverter[io.flow.chuck.onboarding.v0.models.Method] {
        override def convert(value: String): io.flow.chuck.onboarding.v0.models.Method = io.flow.chuck.onboarding.v0.models.Method(value)
        override def convert(value: io.flow.chuck.onboarding.v0.models.Method): String = value.toString
        override def example: io.flow.chuck.onboarding.v0.models.Method = io.flow.chuck.onboarding.v0.models.Method.Get
        override def validValues: Seq[io.flow.chuck.onboarding.v0.models.Method] = io.flow.chuck.onboarding.v0.models.Method.all
      }
      implicit def pathBindableMethod(implicit stringBinder: QueryStringBindable[String]): PathBindable[io.flow.chuck.onboarding.v0.models.Method] = ApibuilderPathBindable(methodConverter)
      implicit def queryStringBindableMethod(implicit stringBinder: QueryStringBindable[String]): QueryStringBindable[io.flow.chuck.onboarding.v0.models.Method] = ApibuilderQueryStringBindable(methodConverter)
    }

    trait ApibuilderTypeConverter[T] {

      def convert(value: String): T

      def convert(value: T): String

      def example: T

      def validValues: Seq[T] = Nil

      def errorMessage(key: String, value: String, ex: java.lang.Exception): String = {
        val base = s"Invalid value '$value' for parameter '$key'. "
        validValues.toList match {
          case Nil => base + "Ex: " + convert(example)
          case values => base + ". Valid values are: " + values.mkString("'", "', '", "'")
        }
      }
    }

    object ApibuilderTypes {
      import org.joda.time.{format, DateTime, LocalDate}

      val dateTimeIso8601: ApibuilderTypeConverter[DateTime] = new ApibuilderTypeConverter[DateTime] {
        override def convert(value: String): DateTime = format.ISODateTimeFormat.dateTimeParser.parseDateTime(value)
        override def convert(value: DateTime): String = format.ISODateTimeFormat.dateTime.print(value)
        override def example: DateTime = DateTime.now
      }

      val dateIso8601: ApibuilderTypeConverter[LocalDate] = new ApibuilderTypeConverter[LocalDate] {
        override def convert(value: String): LocalDate = format.ISODateTimeFormat.yearMonthDay.parseLocalDate(value)
        override def convert(value: LocalDate): String = value.toString
        override def example: LocalDate = LocalDate.now
      }

    }

    final case class ApibuilderQueryStringBindable[T](
      converters: ApibuilderTypeConverter[T]
    ) extends QueryStringBindable[T] {

      override def bind(key: String, params: Map[String, Seq[String]]): _root_.scala.Option[_root_.scala.Either[String, T]] = {
        params.getOrElse(key, Nil).headOption.map { v =>
          try {
            Right(
              converters.convert(v)
            )
          } catch {
            case ex: java.lang.Exception => Left(
              converters.errorMessage(key, v, ex)
            )
          }
        }
      }

      override def unbind(key: String, value: T): String = {
        s"$key=${converters.convert(value)}"
      }
    }

    final case class ApibuilderPathBindable[T](
      converters: ApibuilderTypeConverter[T]
    ) extends PathBindable[T] {

      override def bind(key: String, value: String): _root_.scala.Either[String, T] = {
        try {
          Right(
            converters.convert(value)
          )
        } catch {
          case ex: java.lang.Exception => Left(
            converters.errorMessage(key, value, ex)
          )
        }
      }

      override def unbind(key: String, value: T): String = {
        converters.convert(value)
      }
    }

  }

}
